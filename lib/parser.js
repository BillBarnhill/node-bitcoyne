// Generated by IcedCoffeeScript 1.7.1-e
(function() {
  var Parser, Rational, Script, ScriptParser, Transaction, TransactionIn, TransactionOut, bcdstream, constants, hash160_to_bc_address, hex, i, match_script, obj, opcodes, parse_raw_transaction, pubkey_to_bc_address, tx, txid, _i, _j, _len, _len1, _ref, _ref1, _ref2;

  bcdstream = require('./bcdstream');

  opcodes = require('./opcodes').opcodes;

  Rational = require('./rational').Rational;

  constants = require('./constants').constants;

  match_script = require('./oputil').match_script;

  _ref = require('./pubkey'), hash160_to_bc_address = _ref.hash160_to_bc_address, pubkey_to_bc_address = _ref.pubkey_to_bc_address;

  exports.Transaction = Transaction = (function() {
    function Transaction(_arg) {
      this.id = _arg.id, this.version = _arg.version, this.tx_in = _arg.tx_in, this.tx_out = _arg.tx_out, this.lock_time = _arg.lock_time, this.block_id = _arg.block_id;
    }

    Transaction.prototype.toString = function() {
      var d, k, t, _i, _len, _ref1;
      d = {};
      _ref1 = ["id", "version", "lock_time", "block_id"];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        k = _ref1[_i];
        d[k] = this[k];
      }
      d.tx_in = (function() {
        var _j, _len1, _ref2, _results;
        _ref2 = this.tx_in;
        _results = [];
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          t = _ref2[_j];
          _results.push(t.to_obj());
        }
        return _results;
      }).call(this);
      d.tx_out = (function() {
        var _j, _len1, _ref2, _results;
        _ref2 = this.tx_out;
        _results = [];
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          t = _ref2[_j];
          _results.push(t.to_obj());
        }
        return _results;
      }).call(this);
      return JSON.stringify(d);
    };

    Transaction.prototype.merge = function(smalltx) {
      this.time = smalltx.time;
      this.timereceived = smalltx.timereceived;
      this.block_id = smalltx.blockhash;
      return this.confirmations = smalltx.confirmations;
    };

    return Transaction;

  })();

  exports.TransactionIn = TransactionIn = (function() {
    function TransactionIn(_arg) {
      this.prevout_hash = _arg.prevout_hash, this.prevout_index = _arg.prevout_index, this.script_sig_raw = _arg.script_sig_raw, this.sequence = _arg.sequence, this.from_address = _arg.from_address, this.script_sig = _arg.script_sig, this.version = _arg.version;
    }

    TransactionIn.prototype.to_obj = function() {
      return {
        prevout_index: this.prevout_index,
        sequence: this.sequence,
        from_address: this.from_address,
        script_sig: this.script_sig.to_obj(),
        prevout_hash: this.prevout_hash.inspect(),
        script_sig_raw: this.script_sig_raw.inspect()
      };
    };

    TransactionIn.prototype.prevout_hash_hex = function() {
      return (new Buffer(this.prevout_hash, 'binary')).toString('hex');
    };

    TransactionIn.prototype.extract_from_address = function() {
      var desired, ok, s;
      s = this.script_sig;
      desired = [opcodes.OP_PUSHDATA1, opcodes.OP_PUSHDATA1];
      ok = false;
      if (s.match(desired)) {
        this.from_address = pubkey_to_bc_address(s.command(1).data, this.version);
        ok = true;
      }
      return ok;
    };

    return TransactionIn;

  })();

  exports.TransactionOut = TransactionOut = (function() {
    function TransactionOut(_arg) {
      this.value = _arg.value, this.script_pubkey_raw = _arg.script_pubkey_raw, this.script_pubkey = _arg.script_pubkey, this.to_address = _arg.to_address, this.version = _arg.version;
    }

    TransactionOut.prototype.to_obj = function() {
      return {
        script_pubkey: this.script_pubkey.to_obj(),
        to_address: this.to_address,
        value: this.value.inspect(),
        script_pubkey_raw: this.script_pubkey_raw.inspect()
      };
    };

    TransactionOut.prototype.extract_to_address = function() {
      var desired, ok, s;
      s = this.script_pubkey;
      desired = [opcodes.OP_DUP, opcodes.OP_HASH160, opcodes.OP_PUSHDATA1, opcodes.OP_EQUALVERIFY, opcodes.OP_CHECKSIG];
      ok = false;
      if (s.match(desired)) {
        this.to_address = hash160_to_bc_address(s.command(2).data, this.version);
        ok = true;
      }
      return ok;
    };

    return TransactionOut;

  })();

  exports.Script = Script = (function() {
    function Script(script) {
      this.script = script;
    }

    Script.prototype.match = function(ops) {
      return match_script(this.script, ops);
    };

    Script.prototype.to_obj = function() {
      var p, _i, _len, _ref1, _ref2, _results;
      _ref1 = this.script;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        p = _ref1[_i];
        _results.push([p[0], (_ref2 = p[1]) != null ? _ref2.inspect() : void 0]);
      }
      return _results;
    };

    Script.prototype.command = function(n) {
      var c;
      if ((c = this.script[n]) != null) {
        return {
          op: c[0],
          data: c[1]
        };
      } else {
        return {};
      }
    };

    return Script;

  })();

  exports.Parser = Parser = (function() {
    function Parser(_buffer, version) {
      this._buffer = _buffer;
      this.version = version;
      this._s = new bcdstream.Stream(this._buffer);
    }

    Parser.prototype.parse = function() {
      var i, lock_time, n_tx_in, n_tx_out, tx_in, tx_out, version;
      version = this._s.read_int32();
      n_tx_in = this._s.read_compact_size();
      tx_in = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; 0 <= n_tx_in ? _i < n_tx_in : _i > n_tx_in; i = 0 <= n_tx_in ? ++_i : --_i) {
          _results.push(this.parse_tx_in());
        }
        return _results;
      }).call(this);
      n_tx_out = this._s.read_compact_size();
      tx_out = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; 0 <= n_tx_out ? _i < n_tx_out : _i > n_tx_out; i = 0 <= n_tx_out ? ++_i : --_i) {
          _results.push(this.parse_tx_out());
        }
        return _results;
      }).call(this);
      lock_time = this._s.read_uint32();
      return new Transaction({
        version: version,
        tx_in: tx_in,
        tx_out: tx_out,
        lock_time: lock_time
      });
    };

    Parser.prototype.parse_tx_in = function() {
      var sp, t;
      t = new TransactionIn({
        prevout_hash: this._s.read_bytes(32),
        prevout_index: this._s.read_uint32(),
        script_sig_raw: this._s.read_string(),
        sequence: this._s.read_uint32(),
        version: this.version
      });
      sp = new ScriptParser(new Buffer(t.script_sig_raw, 'binary'));
      if ((t.script_sig = sp.parse()) != null) {
        t.extract_from_address();
      }
      return t;
    };

    Parser.prototype.parse_tx_out = function() {
      var sp, t;
      t = new TransactionOut({
        value: new Rational(this._s.read_int64()).idiv(constants.scale),
        script_pubkey_raw: this._s.read_string(),
        version: this.version
      });
      sp = new ScriptParser(new Buffer(t.script_pubkey_raw, 'binary'));
      if ((t.script_pubkey = sp.parse()) != null) {
        t.extract_to_address();
      }
      return t;
    };

    return Parser;

  })();

  exports.ScriptParser = ScriptParser = (function() {
    function ScriptParser(_buffer) {
      this._buffer = _buffer;
      this._i = 0;
      this._ops = [];
    }

    ScriptParser.prototype.parse = function() {
      var commands;
      commands = ((function() {
        var _results;
        _results = [];
        while (this._i < this._buffer.length) {
          _results.push(this.parse_op());
        }
        return _results;
      }).call(this));
      return new Script(commands);
    };

    ScriptParser.prototype.parse_op = function() {
      var end, n_bytes, opcode, script;
      opcode = this._buffer[this._i];
      this._i++;
      n_bytes = null;
      script = null;
      if (opcode === opcodes.OP_PUSHDATA4) {
        n_bytes = this._buffer.readUInt32LE(this._i);
        this._i += 4;
      } else if (opcode === opcodes.OP_PUSHDATA2) {
        n_bytes = this._buffer.readUInt16LE(this._i);
        this._i += 2;
      } else if (opcode === opcodes.OP_PUSHDATA1) {
        n_bytes = this._buffer[this._i];
        this._i++;
      } else if (opcode < opcodes.OP_PUSHDATA1) {
        n_bytes = opcode;
      }
      if (n_bytes != null) {
        end = this._i + n_bytes;
        if (end > this._buffer.length) {
          end = this._buffer.length;
        }
        script = this._buffer.slice(this._i, end);
        this._i = end;
      }
      return [opcode, script];
    };

    return ScriptParser;

  })();

  exports.parse_raw_transaction = parse_raw_transaction = function(txid, obj, version) {
    var b, p, tx;
    b = new Buffer(obj.hex, 'hex');
    p = new Parser(b, version);
    tx = p.parse();
    tx.blockid = obj.blockhash;
    tx.confirmations = obj.confirmations;
    tx.id = txid;
    return tx;
  };

  if (true) {
    txid = 'd49a2ed7b03a441e2a91070111457a91717034827fca5d020700e3ef9cd88df8';
    hex = '0100000001695be69fefcb43ddbed7be404c9865533c344126140042d05cea013727277ad2000000006b483045022100e9471068a564ac23a625a98765ae3f09b9cc20b2f7b19af751f9a93368e6565a02202063edaa0d894be4b3ebd7ac8c0853a416383df9dc2b0c5df6a19e91065db5050121038972c357ee6c7f5db6136b608f24c7a6ffa2f34db396badd12e98027c542f0f7ffffffff02c0c62d00000000001976a914688d5a5f664da2142553afaf9b4d5cbb200ef53f88ac40aefd7c000000001976a914180c7b82410db0f1471583433f7b3b3c65b7eb2988ac00000000';
    hex = '010000000196a5f90ff8ca5a91a11310ad0d8ae3ccdcdb98a9c903d099aff4391b132a9195080000006b483045022100f87592fc7b204675768a0e0480cb77cbe4426391cfdb7700ce6f6a801c3460860220268d5491e240a93e63c58bbde9f3a287e2ea203f1f0d4c8aa290d3ef7c46d9d30121033a2e08b2293d44d1f14abd91ab59320ef661f6bd30a82df531d3acb7c090ff2bffffffff0100000000000000001976a91452960e1b213813097f3ae22632e31de195bee86e88ac00000000';
    obj = {
      hex: hex
    };
    console.log("ZDZZ");
    tx = parse_raw_transaction(txid, obj);
    console.log(tx);
    _ref1 = tx.tx_in;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      i = _ref1[_i];
      console.log(i.script_sig);
    }
    _ref2 = tx.tx_out;
    for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
      i = _ref2[_j];
      console.log(i.script_pubkey);
    }
  }

}).call(this);
